******************************
OOP 
******************************
******************************

- Object-oriented programming (OOP) is a programming paradigm based on the concept of objects;
- We use objects to model (describe) real-world or abstract features;
- Objects may contain data (properties) and code (methods). By using objects, we pack data and the corresponding behavior into one block;
- In OOP, objects are self-contained pieces/blocks of code;
- Objects are building blocks of applications, and interact with one another;
- Interactions happen through a public interface (API): methods that the code outside of the object can access and use to communicate with the object;

Key Differences:
Aspect	         Class	                                       Object
Definition	      A blueprint/template for creating objects	   A specific instance created from a class
Purpose	         Defines structure and behavior	            Represents a concrete entity
Instantiation	   Cannot exist alone; used to create objects	Exists in memory and has actual data
Memory	         Does not consume memory on its own	         Consumes memory (actual object)
Reusability	      Can be reused to create many objects	      Each object is unique
Usage	            Used to define templates	                  Used to represent real-world entities
Example	         class Car	                                 let car1 = new Car('Toyota', 'Corolla')
Summary:
Class is a template for defining what objects will look like and how they will behave.
Object is an instance of a class, with real-world data and methods based on the class definition.

Abstraction: Hiding unnecessary details.
Encapsulation: Wrapping data and methods into a single unit.
Inheritance: Creating new classes from existing ones.
Polymorphism: Allowing objects to be treated as instances of their parent class.


**** What is Instantiation?
Instantiation is the process of creating an instance (a concrete realization) of a class or object in programming. When you define a class, it acts as a blueprint, and instantiating it means creating an object that follows that blueprint.

Key Concepts
Class: A blueprint or template for creating objects.
Instance: An actual object created from a class.
Instantiation in Different Languages
1. JavaScript
In JavaScript, instantiation is done using the new keyword with a class or constructor function.

Example using a class:
javascript
Kodu kopyala
class Car {
  constructor(make, model) {
    this.make = make;
    this.model = model;
  }

  display() {
    console.log(`This car is a ${this.make} ${this.model}.`);
  }
}

// Instantiating the class
const myCar = new Car("Toyota", "Corolla");
myCar.display(); // Output: This car is a Toyota Corolla.
Example using a constructor function (older way):
javascript
Kodu kopyala
function Car(make, model) {
  this.make = make;
  this.model = model;
}

Car.prototype.display = function () {
  console.log(`This car is a ${this.make} ${this.model}.`);
};

// Instantiating the constructor function
const myCar = new Car("Honda", "Civic");
myCar.display(); // Output: This car is a Honda Civic.

Why is Instantiation Important?
Reusability: Classes provide a reusable blueprint for creating multiple objects.
Modularity: Separates data (attributes) and behavior (methods) into manageable units.
Encapsulation: Helps in bundling data and methods together.

**** 
JavaScript'te `prototype`, `__proto__`, `prototype chain` (prototip zinciri) ve bunlar캼n farklar캼n캼 basit bir 른kilde a칞캼klayacak 칬rnek bir tan캼mlama yapal캼m. Akl캼n캼zda daha kolay kalmas캼 i칞in g칲nl칲k hayattan bir benzetmeyle a칞캼klamaya 칞al캼르ca캼m.

---

### **1. `prototype` Nedir?**
Her fonksiyonun (constructor fonksiyonlar캼n캼n) bir `prototype` 칬zelli를 vard캼r. Bu, o fonksiyonla olu릆urulan t칲m nesnelerin ortak olarak kullanabilece를 칬zellikleri ve metotlar캼 bar캼nd캼r캼r.  

#### 칐rnek:
- `prototype` bir "miras" gibidir: Anne-baban캼zdan size ge칞en 칬zellikler gibi.
- 칐rne를n: 

```javascript
function Person(name) {
    this.name = name;
}

Person.prototype.sayHello = function () {
    console.log(`Hello, my name is ${this.name}`);
};

const person1 = new Person("Raul");
person1.sayHello(); // Hello, my name is Raul
```

**A칞캼klama:**  
`Person` fonksiyonunun `prototype` 칬zelli를nde `sayHello` metodu tan캼mland캼. `person1`, `Person` fonksiyonundan t칲retildi를 i칞in bu metodu kullanabilir.

---

### **2. `__proto__` Nedir?**
Bir nesnenin `__proto__` 칬zelli를, o nesnenin **prototipine** bir referans verir. Bu, nesne hangi "kal캼ptan" t칲remi릅e o kal캼b캼 g칬sterir.

#### 칐rnek:
- `__proto__`, sizin "DNA ba륿ant캼n캼z" gibidir: Kimin soyundan geldi를nizi g칬sterir.

```javascript
console.log(person1.__proto__ === Person.prototype); // true
```

**A칞캼klama:**  
`person1.__proto__`, `Person.prototype`'i i르ret eder. Bu sayede `person1`, `Person`'캼n prototipinde tan캼mlanan `sayHello` metoduna eri른bilir.

---

### **3. `Prototype Chain` Nedir?**
JavaScript, bir nesne 칲zerinde bir 칬zellik/metot arand캼캼nda 칬nce o nesnenin kendisine bakar. E른r bulamazsa, `__proto__` ile ba륿ant캼l캼 oldu릇 칲st prototipe bakar. Bu s칲re칞 zincirleme olarak devam eder. Bu yap캼ya **prototype chain** (prototip zinciri) denir.

#### 칐rnek:
- Prototip zinciri, "ailenin soy a르c캼" gibidir: 칐nce anneye bakars캼n캼z, orada yoksa b칲y칲kanneye gidersiniz.

```javascript
function Animal(legs) {
    this.legs = legs;
}

Animal.prototype.walk = function () {
    console.log("Walking...");
};

const dog = new Animal(4);
dog.walk(); // Walking...

console.log(dog.hasOwnProperty("legs")); // true (dog'un kendi 칬zelli를)
console.log(dog.hasOwnProperty("walk")); // false (walk prototipten geliyor)
```

**A칞캼klama:**  
- `dog` nesnesi, `walk` metodunu kendi 칲zerinde bulamaz. Bu y칲zden `Animal.prototype`'a bakar ve oradan al캼r.

---

### **4. `prototype` ve `__proto__` Fark캼**
- **`prototype`:** Sadece constructor fonksiyonlarda bulunur. O fonksiyonla olu릆urulan nesneler i칞in prototip 칬zelliklerini tan캼mlar.  
- **`__proto__`:** T칲m nesnelerde bulunur. Nesnenin ba륿캼 oldu릇 prototipi referanslar.

#### 칐zet:
- **`prototype`:** "칐zellikleri aktaran" bir taslak.
- **`__proto__`:** "Aktar캼lan 칬zelliklerin ba륿캼 oldu릇 yer."

---

### **Kolay Anla캼labilir 칐zet Benzetme**
1. `prototype` = Bir **anne/baba** (miras b캼rakan).
2. `__proto__` = 칂ocuklar캼n **ba륿ant캼s캼** (annesini/babas캼n캼 i르ret ediyor).
3. `prototype chain` = **Soy a르c캼** (nesnelerin 칬zellik/metot arama yolu).

Bu benzetmeyle `prototype` kavram캼 umar캼m daha net hale gelir! 

**************************************************************************************************

Evet, doru anlad캼n캼z! 游꿀

JavaScript'te **prototype inheritance (prototip tabanl캼 kal캼t캼m)**, geleneksel s캼n캼f (class)-tabanl캼 kal캼t캼mdan farkl캼d캼r. JavaScript'te nesneler, **di른r nesnelerden** miras al캼r. Bu, "s캼n캼f" kavram캼 olmadan kal캼t캼m캼n ger칞ekle릆i를 anlam캼na gelir. Yani:  

**JavaScript'te nesneler prototipten miras al캼r.**  

---

### **Klasik S캼n캼f Tabanl캼 Kal캼t캼m ile Fark캼**
- Geleneksel s캼n캼f-tabanl캼 dillerde (C++, Java, vb.) s캼n캼flar s캼n캼flardan miras al캼r. Bir s캼n캼f ba륾a bir s캼n캼f캼 geni륿eterek (extend) ondan 칬zellikler/metotlar devral캼r.
- JavaScript'te ise her nesne, bir ba륾a nesneyi prototip olarak kullanabilir ve ondan 칬zellik/metot miras alabilir.

---

### **JavaScript 칐rne를 ile A칞캼klama**
Prototip tabanl캼 kal캼t캼m캼 bir 칬rnekle netle릆irelim:

```javascript
// Bir nesne olu릆ur
const animal = {
    walk() {
        console.log("Animal is walking");
    }
};

// Ba륾a bir nesne yarat ve animal'dan miras al
const dog = Object.create(animal);

dog.bark = function () {
    console.log("Dog is barking");
};

// Kullan캼m:
dog.walk(); // Animal is walking (animal'dan miras ald캼)
dog.bark(); // Dog is barking (kendi 칬zelli를)
```

**A칞캼klama:**
- `dog` nesnesi, `animal` nesnesinden t칲retilmi릆ir.
- `dog.walk()` 칞ar캼ld캼캼nda, JavaScript `dog` nesnesinde `walk` metodunu bulamaz ve `__proto__` ile ba륿캼 oldu릇 `animal` nesnesine gider.

---

### **Prototip Tabanl캼 Kal캼t캼m캼n Mant캼캼**
- **JavaScript'te nesneler direkt olarak di른r nesnelerden t칲reyebilir.**  
- Bu, **`Object.create`** gibi bir yap캼 sayesinde yap캼l캼r.
- Nesneler bir prototip zinciri 칲zerinden 칬zellik/metotlar캼 arar.

---

### **Klas-Tabanl캼 Yakla캼m (ES6 Sonras캼)**
JavaScript ES6 ile **s캼n캼f s칬zdizimi** (class syntax) ekledi, ancak bu sadece bir **s칬zdizimi 른keri** (syntactic sugar)'dir. Alt캼nda yine prototip tabanl캼 kal캼t캼m 칞al캼캼r. Yani JavaScript h칙l칙 prototip tabanl캼 bir dil olmaya devam eder.

```javascript
class Animal {
    walk() {
        console.log("Animal is walking");
    }
}

class Dog extends Animal {
    bark() {
        console.log("Dog is barking");
    }
}

const dog = new Dog();
dog.walk(); // Animal is walking (Animal'dan miras)
dog.bark(); // Dog is barking
```

---

### **Sonu칞**
- **JavaScript'te nesneler prototiplerden miras al캼r.**
- **S캼n캼f kavram캼**, JavaScript'te geleneksel dillerdeki gibi temel bir yap캼 de를l, yaln캼zca bir kullan캼m캼 kolayla릆캼rma arac캼d캼r.
- Temel fark: Geleneksel dillerde s캼n캼flar s캼n캼flardan miras al캼r, JavaScript'te ise **nesneler di른r nesnelerden** miras al캼r.

****************************************************************
Evet, doru! Hem **class** (s캼n캼f) hem de **prototype** bir nesne i칞in **르blon g칬revi** g칬r칲r, ancak bunu farkl캼 른killerde ger칞ekle릆irirler. 캻kisinin de amac캼, nesneler aras캼nda ortak 칬zellikler ve davran캼륿ar payla릀ak, ancak altta yatan mekanizmalar캼 biraz farkl캼d캼r.

---

### **1. Class: Nesne 료blonu (ES6 ile Gelen S칬zdizimi)**
- **Class**, geleneksel anlamda bir "르blon" gibi 칞al캼캼r. 
- S캼n캼f캼 tan캼mlars캼n캼z, o s캼n캼ftan nesneler olu릆urursunuz. S캼n캼fta tan캼mlanan 칬zellik ve metotlar, t칲retilen her nesneye miras kal캼r.

#### 칐rnek:
```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }
    
    speak() {
        console.log(`${this.name} makes a sound.`);
    }
}

const dog = new Animal("Dog");
dog.speak(); // Dog makes a sound.
```

**A칞캼klama:**
- `Animal` s캼n캼f캼 bir 르blondur.
- `dog` nesnesi, `Animal` 르blonundan t칲retilmi릆ir ve 르blondaki `speak` metodunu miras al캼r.

---

### **2. Prototype: Nesne i칞in 료blon**
- Prototipler de bir 르blon g칬revi g칬r칲r. 
- Ancak s캼n캼flar gibi bir s칬zdiziminden ziyade, nesnelerin kendi **ba륿캼 oldu릇 bir prototip** 칲zerinden 칬zellik/metot miras캼 almas캼n캼 sa륿ar.
- JavaScript'in temelinde, asl캼nda her 른y **prototype tabanl캼d캼r.**

#### 칐rnek:
```javascript
function Animal(name) {
    this.name = name;
}

Animal.prototype.speak = function () {
    console.log(`${this.name} makes a sound.`);
};

const dog = new Animal("Dog");
dog.speak(); // Dog makes a sound.
```

**A칞캼klama:**
- `Animal.prototype`, 르blon g칬revi g칬r칲r. `speak` metodu burada tan캼mlan캼r.
- `dog` nesnesi, bu prototipi kullanarak `speak` metoduna eri를r.

---

### **Class ve Prototype Aras캼ndaki Benzerlik**
- **Class ve prototype**, her ikisi de nesneler i칞in bir **르blon** g칬revi g칬r칲r.  
- 캻kisinde de tan캼mlanan 칬zellikler ve metotlar, t칲retilen nesnelere miras kal캼r.

---

### **Class ve Prototype Aras캼ndaki Fark**
1. **S칬zdizimi:**
   - `class` daha okunabilir ve modern bir s칬zdizimi sunar (ES6 ile eklenmi릆ir).
   - `prototype` daha eski bir y칬ntemdir ve daha az sezgiseldir.

2. **Temel Fark:**
   - **Class**: S캼n캼f-tabanl캼 bir sistem gibi g칬r칲nse de altta asl캼nda **prototip-tabanl캼** kal캼t캼m 칞al캼캼r. Yani, s캼n캼f kullan캼lsa bile JavaScript h칙l칙 prototiplerle 칞al캼캼r.
   - **Prototype**: Nesneler aras캼nda dorudan ili륾i kurar, s캼n캼f gibi bir arac캼 yap캼ya gerek yoktur.

---

### **Sonu칞**
Evet, **class** da, **prototype** da nesneler i칞in bir 르blon g칬revi g칬r칲r. Ancak unutulmamal캼 ki JavaScript'in temelinde **prototip tabanl캼 bir yap캼** vard캼r. `class`, sadece bu yap캼y캼 daha kullan캼c캼 dostu bir 른kilde sunar. Yani, class'lar prototiplerin 칲st칲ne in르 edilmi릆ir. 游땕

***********************************************************************************